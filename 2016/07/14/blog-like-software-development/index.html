<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><title>React と Redux なブログ運用をソフトウェア開発する話し | log.sugarshin.net</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="sugarshin | Shingo Sato"><meta name="description" content="継続的なソフトウェア開発プロセスを取り入れ、最低限の SEO は考慮しつつ無理矢理 React でブログを作ってみたという話しです。---個人ブログ開設にあたり何を使おうか迷いまして、いろいろ考えた結果結局 React と Redux で自作しました。過去の経験上、普通にブログを"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml"><link rel="alternate" type="application/rss+xml" title="RSS 2.0 Feed" href="/rss.xml"><link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png"><link rel="manifest" href="/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#fff"><meta name="application-name" content="log.sugarshin.net"><link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="log.sugarshin.net"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png"><link rel="icon" type="image/png" sizes="230x230" href="/favicon-230x230.png"><link rel="shortcut icon" href="/favicon.ico"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/mstile-144x144.png"><meta name="msapplication-config" content="/browserconfig.xml"><meta property="twitter:image" content="https://log.sugarshin.net/assets/images/2016/07/14/blog-like-software-development/main.png"><meta property="og:image" content="https://log.sugarshin.net/assets/images/2016/07/14/blog-like-software-development/main.png"></head><body><div style="display: none"><p><img src="/assets/images/2016/07/14/blog-like-software-development/main.png" alt="Main"></p>
<p>継続的なソフトウェア開発プロセスを取り入れ、最低限の SEO は考慮しつつ無理矢理 React でブログを作ってみたという話しです。</p>
<hr>
<p>個人ブログ開設にあたり何を使おうか迷いまして、いろいろ考えた結果結局 React と Redux で自作しました。</p>
<p>過去の経験上、普通にブログを続けていくだけではモチベーションを保てないなぁと思い、ソフトウェア開発的なプロセスや自動化を取り入れつつという感じです。</p>
<p><a href="https://github.com/sugarshin/log.sugarshin.net">https://github.com/sugarshin/log.sugarshin.net</a></p>
<p>Redux 周りを最近触っていなかったので久しぶりに触りたかったというのも理由付けの1つです。</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8%E3%83%84%E3%83%BC%E3%83%AB">利用ツール</a></li>
<li>
<p><a href="#react">React</a></p>
<ul>
<li><a href="#enzyme">Enzyme</a></li>
</ul>
</li>
<li><a href="#webpack">webpack</a></li>
<li>
<p><a href="#%E9%96%8B%E7%99%BA%E3%80%81%E5%9F%B7%E7%AD%86%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9">開発、執筆プロセス</a></p>
<ul>
<li><a href="#textlint">textlint</a></li>
</ul>
</li>
<li><a href="#%E3%83%93%E3%83%AB%E3%83%89%E3%80%81%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4">ビルド、デプロイ</a></li>
<li><a href="#greenkeeper">Greenkeeper</a></li>
<li><a href="#todos">TODOs</a></li>
</ul>
<h2 id="利用ツール">利用ツール</h2>
<p>主な利用ツールは以下です。</p>
<ul>
<li>React</li>
<li>react-router</li>
<li>Redux</li>
<li>redux-thunk</li>
<li>webpack</li>
<li>Babel with ES2015</li>
<li>CSS Modules</li>
<li>PostCSS</li>
<li>Stylus</li>
<li>Pug</li>
<li>remark</li>
<li>textlint</li>
<li>ESLint</li>
<li>Stylint</li>
<li>Mocha</li>
<li>power-assert</li>
<li>Enzyme</li>
<li>Travis CI</li>
<li>Greenkeeper</li>
</ul>
<p>大まかに順番に解説します。</p>
<h2 id="react">React</h2>
<p>本体は特に変哲もない普通の React + react-router です。 Redux のディレクトリ構成に沿ってはいます。</p>
<p>特に複雑な非同期処理もないので redux-thunk でよっこいしょしています。</p>
<pre><code class="hljs language-sh">src
├── actions
├── apis
├── components
│   ├── Article
│   │   ├── index.js
│   │   └── index.styl
│   ├── ArticleItem
│   │   ├── index.js
│   │   └── index.styl
│   ├── Articles
│   │   ├── index.js
│   │   └── index.styl
│   └── ...
├── constants
│   ├── ActionTypes.js
│   └── initialState.js
├── containers
│   ├── App.js
│   ├── DevTools.js
│   └── ...
├── images
├── index.js
├── reducers
│   ├── article.js
│   ├── articles.js
│   ├── index.js
│   └── ...
├── routes
│   ├── Archives.js
│   ├── Article.js
│   └── ...
├── store
│   ├── configureStore.dev.js
│   ├── configureStore.js
│   └── configureStore.prod.js
├── stylus
├── template
└── utils
</code></pre>
<p>Markdown で書いた記事を XHR で取ってきて remark でレンダリングしています。</p>
<p><a href="">remark</a> はプラガブルな Markdown パーサ &#x26; コンパイラです。</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"rehype-highlight"</span>: <span class="hljs-string">"~1.0.0"</span>,
  <span class="hljs-attr">"rehype-stringify"</span>: <span class="hljs-string">"~1.0.0"</span>,
  <span class="hljs-attr">"remark-parse"</span>: <span class="hljs-string">"~1.0.0"</span>,
  <span class="hljs-attr">"remark-rehype"</span>: <span class="hljs-string">"~1.0.0"</span>,
  <span class="hljs-attr">"remark-toc"</span>: <span class="hljs-string">"~3.0.1"</span>,
  <span class="hljs-attr">"remark-yaml-config"</span>: <span class="hljs-string">"~3.0.2"</span>,
  <span class="hljs-attr">"unified"</span>: <span class="hljs-string">"~4.1.2"</span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> unified = <span class="hljs-built_in">require</span>(<span class="hljs-string">'unified'</span>);
<span class="hljs-keyword">const</span> parse = <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-parse'</span>);
<span class="hljs-keyword">const</span> toc = <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-toc'</span>);
<span class="hljs-keyword">const</span> yamlConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-yaml-config'</span>);
<span class="hljs-keyword">const</span> remarkToRehype = <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-rehype'</span>);
<span class="hljs-keyword">const</span> highlight = <span class="hljs-built_in">require</span>(<span class="hljs-string">'rehype-highlight'</span>);
<span class="hljs-keyword">const</span> stringify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'rehype-stringify'</span>);

unified()
  .use(parse)
  .use(toc)
  .use(yamlConfig)
  .use(remarkToRehype)
  .use(highlight)
  .use(stringify)
  .process(<span class="hljs-string">'# markdown'</span>);
</code></pre>
<h3 id="enzyme">Enzyme</h3>
<p>React コンポーネントのテストは <a href="https://github.com/airbnb/enzyme">Enzyme</a> を使ってみました。普通に DOM を触っている感じでテストが書けるので面白いかなと思います。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'assert'</span>;
<span class="hljs-keyword">import</span> { shallow } <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

describe(<span class="hljs-string">'Article suite'</span>, () => {
  <span class="hljs-keyword">const</span> Article = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../src/components/Article'</span>).default;
  it(<span class="hljs-string">'contains spec with an expectation'</span>, () => {
    <span class="hljs-keyword">const</span> markdown = <span class="hljs-string">''</span>;
    assert(shallow(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Article</span> <span class="hljs-attr">article</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">markdown</span> }} /></span>).is('.markdown-body'));
  });
});
</span></code></pre>
<p>テスト周りは Mocha, power-assert, babel-preset-power-assert, なこちらも定番な感じす。</p>
<p>が、まだテストはほとんど書けてません。。</p>
<h2 id="webpack">webpack</h2>
<p>webpack はやれることが多くドキュメントは充実しているとは言い難いですが、これじゃないといろいろ実現しないですね。</p>
<p>また、 CSS Modules は css-loader で実現しています。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> production = process.env.NODE_ENV === <span class="hljs-string">'production'</span>;
<span class="hljs-keyword">const</span> localIdentName = production ? <span class="hljs-string">'[hash:base64:32]'</span> : <span class="hljs-string">'[path][name]__[local]___[hash:base64:8]'</span>;
<span class="hljs-keyword">const</span> cssModules = <span class="hljs-string">`modules&#x26;importLoaders=1&#x26;localIdentName=<span class="hljs-subst">${localIdentName}</span>`</span>;
<span class="hljs-keyword">const</span> cssLoader = production ? <span class="hljs-string">`css?minimize&#x26;<span class="hljs-subst">${cssModules}</span>`</span> : <span class="hljs-string">`css?<span class="hljs-subst">${cssModules}</span>`</span>;
</code></pre>
<p>コンポーネントを意識した構成にさえしていれば、ある程度雑に CSS を書いても大丈夫ですし、面倒な class 命名に悩む必要もないのでとっても気に入っています。</p>
<p>Stylus で書いて PostCSS でポストプロセスしつつ最終的に style-loader でインライン化しています。</p>
<pre><code class="hljs language-js">{
  test: <span class="hljs-regexp">/\.styl$/</span>,
  loaders: [<span class="hljs-string">'style'</span>, <span class="hljs-string">'css'</span>, <span class="hljs-string">'postcss'</span>, <span class="hljs-string">'stylus'</span>]
}
</code></pre>
<p>CSS ファイルの管理を意識しなくていいので楽です。</p>
<h2 id="開発、執筆プロセス">開発、執筆プロセス</h2>
<p><code>npm start</code> で開発サーバが立ち上がります。</p>
<p>その他、記事一覧のデータをとるための JSON ファイルを生成したり、本番で記事情報を取ってきている GitHub API のモックとして利用するファイルを生成したりしています。</p>
<p>新しい記事を書くときは <code>npm run na -- --name example-name</code> で <code>.md</code> ファイルと必要なディレクトリを生成します。</p>
<h3 id="textlint">textlint</h3>
<p><a href="https://github.com/textlint/textlint">textlint</a> を利用し、自然言語のリントも行っています。</p>
<p>文章のフォーマットなどは気分によって変わる場合もあったり、文章校正はどうしてもヒューマンエラーが起こるのでこういうツールに丸投げするのも有りですね。</p>
<p>こちらもビルド時にその他リントと一緒に走ります。</p>
<p>採用ルールは一旦こんな感じです。</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"filters"</span>: {
    <span class="hljs-attr">"comments"</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">"rules"</span>: {
    <span class="hljs-attr">"sentence-length"</span>: {
      <span class="hljs-attr">"max"</span>: <span class="hljs-number">140</span>
    },
    <span class="hljs-attr">"max-comma"</span>: {
      <span class="hljs-attr">"max"</span>: <span class="hljs-number">3</span>
    },
    <span class="hljs-attr">"max-ten"</span>: {
      <span class="hljs-attr">"max"</span>: <span class="hljs-number">3</span>
    },
    <span class="hljs-attr">"max-kanji-continuous-len"</span>: {
      <span class="hljs-attr">"max"</span>: <span class="hljs-number">5</span>
    },
    <span class="hljs-attr">"no-mix-dearu-desumasu"</span>: {
      <span class="hljs-attr">"preferInHeader"</span>: <span class="hljs-string">""</span>,
      <span class="hljs-attr">"preferInBody"</span>: <span class="hljs-string">"ですます"</span>,
      <span class="hljs-attr">"preferInList"</span>: <span class="hljs-string">"である"</span>,
      <span class="hljs-attr">"strict"</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">"no-double-negative-ja"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"no-dropping-the-ra"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"no-doubled-conjunctive-particle-ga"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"no-hankaku-kana"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"ja-no-successive-word"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"ja-no-abusage"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"preset-jtf-style"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"eslint"</span>: {
      <span class="hljs-attr">"configFile"</span>: <span class="hljs-string">".eslintrc"</span>
    }
  }
}
</code></pre>
<p>記事内のコードブロックに対しても ESLint でリントします。</p>
<h2 id="ビルド、デプロイ">ビルド、デプロイ</h2>
<p>ホスティングは GitHub Pages です。</p>
<p>なので、 SEO のためにも各記事ごとに静的ファイルを用意しないといけないのですが、</p>
<p>当初は <code>ReactDOMServer.renderToString</code> でビルド時に、サーバーサイドレンダリングライクな感じで吐いて、クライアントでレンダリング済みの DOM と React がスムーズに連携できる予定でしたがうまくいかず。。</p>
<p>結局、 <a href="https://github.com/pugjs/pug">Pug</a> で各ページ分、内容を雑にレンダリングして内容部分は <code>style="display: none;"</code> しつつ生成するようにしています。笑</p>
<p>これで各ページ分クロールもされ、アクセス後は SPA として動作します。</p>
<p>Google Search Console でも今のところ特に問題視されていません。</p>
<p>その他、 sitemap.xml や RSS, Atom フィード用の xml 、 Favicon, OG 画像等もビルド時に script でつくっています。</p>
<p>master ブランチにマージされると、テスト、ビルド、デプロイと Travis CI で CI がまわります。</p>
<h2 id="greenkeeper">Greenkeeper</h2>
<p><a href="https://greenkeeper.io/">Greeankeeper</a> でライブラリの最新化もほぼ自動化しています。</p>
<p>利用ライブラリにアップデートがあると Bot からプルリクがとんでくるのであとは CI が通ればマージするだけです。</p>
<p><code>npm-check-updates</code> よりも楽かなと思います。</p>
<p>OSS のリポジトリだと無料で利用できるので、他の自分の OSS でも利用しています。</p>
<h2 id="todos">TODOs</h2>
<ul>
<li>テストをかく</li>
<li><code>ReactDOMServer.renderToString</code> でスマートにしたい</li>
<li>SEO をもう少しがんばる</li>
<li>もろもろ整理、パッケージにして OSS 化（React static blog generator ?）したい</li>
</ul></div><div id="app-root"></div><script src="/assets/app-8e82873a003273d5cff3.js"></script></body></html>